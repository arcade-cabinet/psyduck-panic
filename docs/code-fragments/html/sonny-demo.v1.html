<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NS-5 Sonny • Procedural Masterpiece</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #ui {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 380px; background: rgba(10,15,20,0.75); border: 1px solid #445577;
            border-radius: 12px; padding: 18px 20px; color: #aaccff;
            backdrop-filter: blur(12px); text-align: center; z-index: 100; box-shadow: 0 8px 32px rgba(0,0,0,0.6);
        }
        .label { font-size: 10px; letter-spacing: 3px; text-transform: uppercase; margin-bottom: 6px; 
            display: flex; justify-content: space-between; color: #88bbff; font-weight: 500; }
        input[type=range] { width: 100%; -webkit-appearance: none; background: transparent; margin: 10px 0; }
        input[type=range]::-webkit-slider-runnable-track { height: 3px; background: linear-gradient(90deg,#88bbff,#ff3366); border-radius: 3px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px;
            background: #ffffff; border: 2px solid #88bbff; border-radius: 50%; margin-top: -6px; cursor: pointer; box-shadow: 0 0 12px #88bbff; }
        #info {
            position: absolute; top: 20px; left: 20px; color: #6688aa; font-size: 11px; pointer-events: none;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>
<div id="ui">
    <div class="label"><span>CORTICAL STRESS</span><span id="val">0%</span></div>
    <input type="range" id="tensionSlider" min="0" max="100" value="0">
</div>
<div id="info">NS-5 Sonny • Procedural Bust • Orbit + Mouse Look • Drag slider for stress reaction</div>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
    }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

const lerp = THREE.MathUtils.lerp;
const ss = (a, b, x) => { const t = Math.max(0, Math.min(1, (x - a) / (b - a))); return t * t * (3 - 2 * t); };
const gauss = (x, c, s) => Math.exp(-((x - c) ** 2) / (2 * s * s));

/* ====================== TEXTURES ====================== */
function makeTex(fn, w = 1024, h = 1024) {
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    fn(c.getContext('2d'), w, h);
    const t = new THREE.CanvasTexture(c);
    t.wrapS = t.wrapT = THREE.RepeatWrapping;
    t.anisotropy = 16;
    return t;
}
const shellNormal = makeTex((ctx, w, h) => {
    ctx.fillStyle = '#111111';
    ctx.fillRect(0, 0, w, h);
    ctx.strokeStyle = '#555555';
    ctx.lineWidth = 1.5;
    for (let i = 0; i < 800; i++) {
        const x = Math.random() * w;
        const y = Math.random() * h;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + (Math.random() - 0.5) * 18, y + (Math.random() - 0.5) * 18);
        ctx.stroke();
    }
}, 512, 512);
shellNormal.repeat.set(3, 3);

const cableBump = makeTex((ctx, w, h) => {
    ctx.fillStyle = '#222222';
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = '#444444';
    for (let i = 0; i < 1200; i++) {
        ctx.fillRect(Math.random() * w, Math.random() * h, 3 + Math.random() * 4, 1);
    }
});

/* ====================== SCENE SETUP ====================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1f24);
scene.fog = new THREE.FogExp2(0x1a1f24, 0.0095);

const camera = new THREE.PerspectiveCamera(32, innerWidth / innerHeight, 0.1, 100);
camera.position.set(0, 0.35, 5.2);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2.5));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.45;
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.085;
controls.minDistance = 2.2;
controls.maxDistance = 9;
controls.target.set(0, -0.08, 0);
controls.enablePan = false;

/* ====================== MATERIALS ====================== */
const shellMat = new THREE.MeshPhysicalMaterial({
    color: 0xf0f2f6,
    roughness: 0.22,
    metalness: 0.08,
    clearcoat: 0.65,
    clearcoatRoughness: 0.12,
    transmission: 0.07,
    thickness: 5.5,
    ior: 1.42,
    envMapIntensity: 0.9,
    normalMap: shellNormal,
    normalScale: new THREE.Vector2(0.8, 0.8)
});

const faceMat = shellMat.clone();
faceMat.transmission = 0.09;
faceMat.thickness = 6.2;
faceMat.roughness = 0.19;

const darkMat = new THREE.MeshStandardMaterial({ color: 0x0b0b0f, roughness: 0.48, metalness: 0.92 });
const jointMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.25, metalness: 0.95 });
const cableMat = new THREE.MeshStandardMaterial({
    color: 0x111115,
    roughness: 0.55,
    metalness: 0.25,
    bumpMap: cableBump,
    bumpScale: 0.035
});
const boneMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.18, metalness: 0.88 });

const eyeCoreMat = new THREE.MeshStandardMaterial({
    color: 0x88bbff,
    emissive: 0x3366aa,
    emissiveIntensity: 0.9,
    roughness: 0.05,
    metalness: 0.6
});
const irisMat = new THREE.MeshStandardMaterial({
    color: 0xaaddff,
    emissive: 0x5588dd,
    emissiveIntensity: 1.2,
    roughness: 0.02,
    metalness: 0.4
});

/* ====================== ENVIRONMENT ====================== */
const wallMat = new THREE.MeshStandardMaterial({
    color: 0x445055,
    roughness: 0.85,
    metalness: 0.15
});
const wall = new THREE.Mesh(new THREE.PlaneGeometry(18, 12), wallMat);
wall.position.set(0, 0.8, -5.5);
wall.receiveShadow = true;
scene.add(wall);

const floor = new THREE.Mesh(new THREE.PlaneGeometry(18, 18), new THREE.MeshStandardMaterial({ color: 0x1c1f22, roughness: 0.9 }));
floor.rotation.x = -Math.PI / 2;
floor.position.y = -2.1;
floor.receiveShadow = true;
scene.add(floor);

const table = new THREE.Mesh(new THREE.BoxGeometry(4.2, 0.08, 2.1), new THREE.MeshStandardMaterial({ color: 0x2a2e33, roughness: 0.4, metalness: 0.7 }));
table.position.set(0, -1.42, 0.8);
table.castShadow = table.receiveShadow = true;
scene.add(table);

const tableEdge = new THREE.Mesh(new THREE.BoxGeometry(4.3, 0.1, 0.06), new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.85 }));
tableEdge.position.set(0, -1.38, 1.65);
scene.add(tableEdge);

/* ====================== PROCEDURAL HELPERS ====================== */
function sculptGeo(geo, fn) {
    const pos = geo.attributes.position;
    const v = new THREE.Vector3();
    for (let i = 0; i < pos.count; i++) {
        v.fromBufferAttribute(pos, i);
        fn(v, v.x, v.y, v.z);
        pos.setXYZ(i, v.x, v.y, v.z);
    }
    geo.computeVertexNormals();
    return geo;
}

/* ====================== ROBOT ====================== */
const robot = new THREE.Group();
scene.add(robot);

/* ====================== HEAD ====================== */
const headGroup = new THREE.Group();
headGroup.position.y = 0.62;
headGroup.scale.set(0.87, 0.81, 0.87);
robot.add(headGroup);

const headGeo = new THREE.IcosahedronGeometry(0.245, 4);
sculptGeo(headGeo, (v, x, y, z) => {
    // Overall oval
    v.y *= 1.12;
    v.x *= 0.96;
    v.z *= 1.04;

    // Face plate flattening
    if (z > 0.04 && Math.abs(x) < 0.23 && y > -0.29 && y < 0.24) {
        const face = ss(0.04, 0.22, z) * (1 - Math.abs(x) / 0.24);
        v.z -= face * 0.092;
    }

    // Brow ridge
    if (y > 0.06 && y < 0.14 && z > 0.09) {
        const b = gauss(y, 0.10, 0.022) * (1 - gauss(x, 0, 0.04) * 0.35);
        v.z += b * 0.048;
    }

    // Eye sockets
    for (const ex of [-0.108, 0.108]) {
        const dx = x - ex, dy = y - 0.038, dz = z - 0.265;
        const d = Math.sqrt(dx * dx * 0.75 + dy * dy * 2.8 + dz * dz);
        if (d < 0.092) v.z -= (1 - d / 0.092) ** 1.9 * 0.062;
    }

    // Nose bridge
    if (z > 0.11 && Math.abs(x) < 0.028 && y > -0.13 && y < 0.07) {
        v.z += gauss(x, 0, 0.015) * (1 - Math.abs(y + 0.03) / 0.11) * 0.058;
    }

    // Mouth
    if (z > 0.14 && Math.abs(x) < 0.068 && y > -0.215 && y < -0.158) {
        v.z -= gauss(y, -0.186, 0.011) * (1 - gauss(x, 0, 0.055) * 0.3) * 0.021;
    }

    // Chin
    if (y < -0.23 && y > -0.35 && z > 0.04 && Math.abs(x) < 0.085) {
        v.z += gauss(y, -0.29, 0.035) * gauss(x, 0, 0.055) * 0.028;
    }

    // Cheeks
    if (y > -0.08 && y < 0.06 && z > 0.02) {
        const ch = gauss(Math.abs(x), 0.17, 0.045) * gauss(y, -0.01, 0.035);
        v.x += Math.sign(x) * ch * 0.017;
        v.z += ch * 0.022;
    }

    // Temples
    if (Math.abs(x) > 0.205 && y > -0.03 && y < 0.13) {
        v.x -= Math.sign(x) * gauss(Math.abs(x), 0.265, 0.035) * 0.014;
    }

    // Ears / sensor housings
    if (Math.abs(x) > 0.275 && y > -0.05 && y < 0.09) {
        const e = gauss(y, 0.02, 0.032) * gauss(Math.abs(x), 0.33, 0.028);
        v.x += Math.sign(x) * e * 0.0095;
        v.z += e * 0.007;
    }

    // Back of head flattening
    if (z < -0.13) v.z *= 0.94 + ss(-0.13, -0.28, z) * 0.07;
});

const headShell = new THREE.Mesh(headGeo, faceMat);
headShell.castShadow = headShell.receiveShadow = true;
headGroup.add(headShell);

// Dark under-skull
const underSkull = new THREE.Mesh(headGeo.clone(), darkMat);
underSkull.scale.setScalar(0.935);
underSkull.position.z = -0.018;
headGroup.add(underSkull);

// Seams
const vSeam = new THREE.Mesh(new THREE.BoxGeometry(0.003, 0.78, 0.003), new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.9 }));
vSeam.position.set(0, -0.015, 0.325);
headGroup.add(vSeam);

const hSeam = new THREE.Mesh(new THREE.TorusGeometry(0.295, 0.0018, 6, 48, Math.PI * 0.83), jointMat);
hSeam.rotation.set(Math.PI * 0.52, 0, Math.PI * 0.61);
hSeam.position.set(0, 0.135, 0.06);
headGroup.add(hSeam);

// Eyes
function makeEye(x) {
    const g = new THREE.Group();
    const socket = new THREE.Mesh(new THREE.TorusGeometry(0.037, 0.0055, 12, 24), jointMat);
    socket.position.z = 0.004;
    g.add(socket);

    const core = new THREE.Mesh(new THREE.SphereGeometry(0.0255, 32, 32), eyeCoreMat);
    g.add(core);

    const iris = new THREE.Mesh(new THREE.TorusGeometry(0.0155, 0.004, 12, 24), irisMat);
    iris.position.z = 0.013;
    g.add(iris);

    const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.0075, 16, 16), new THREE.MeshStandardMaterial({ color: 0x111122, roughness: 0.1 }));
    pupil.position.z = 0.021;
    g.add(pupil);

    const lens = new THREE.Mesh(new THREE.CircleGeometry(0.031, 32), new THREE.MeshPhysicalMaterial({
        color: 0xffffff, transmission: 0.85, roughness: 0, metalness: 0.1, transparent: true, opacity: 0.25
    }));
    lens.position.z = 0.029;
    g.add(lens);

    const light = new THREE.PointLight(0x99ccff, 0.6, 0.8);
    g.add(light);

    g.position.set(x, 0.042, 0.268);
    return { group: g, light, core, iris };
}
const eyeL = makeEye(-0.108);
const eyeR = makeEye(0.108);
const eyePivot = new THREE.Group();
eyePivot.add(eyeL.group, eyeR.group);
headGroup.add(eyePivot);

/* ====================== NECK ====================== */
const neck = new THREE.Group();
neck.position.y = 0.135;
robot.add(neck);

neck.add(new THREE.Mesh(new THREE.CylinderGeometry(0.048, 0.068, 0.41, 16), darkMat));

// Vertebrae rings
const ringGeo = new THREE.TorusGeometry(0.1, 0.009, 8, 20);
for (let i = 0; i < 5; i++) {
    const r = new THREE.Mesh(ringGeo, i % 2 ? boneMat : jointMat);
    r.rotation.x = Math.PI / 2;
    r.position.y = -0.135 + i * 0.092;
    r.scale.setScalar(1.02 - i * 0.09);
    neck.add(r);
}

// Exposed spine pistons
for (let i = 0; i < 4; i++) {
    const p = new THREE.Mesh(new THREE.CylinderGeometry(0.0115, 0.0115, 0.39, 8), boneMat);
    p.position.set(0, -0.02 + i * 0.085, -0.055);
    neck.add(p);
}

// Hydraulic cables (4 thick)
const cableOffsets = [[-0.072, 0.042], [0.072, 0.042], [-0.055, -0.052], [0.055, -0.052]];
cableOffsets.forEach(([x, z]) => {
    const points = [
        new THREE.Vector3(x, 0.19, z),
        new THREE.Vector3(x * 1.05, 0.05, z * 1.08),
        new THREE.Vector3(x * 0.95, -0.12, z * 0.95),
        new THREE.Vector3(x * 0.88, -0.22, z * 0.88)
    ];
    const curve = new THREE.CatmullRomCurve3(points, false, 'catmullrom', 0.42);
    const tube = new THREE.Mesh(new THREE.TubeGeometry(curve, 24, 0.0078, 8, false), cableMat);
    neck.add(tube);
});

/* ====================== TORSO ====================== */
const torsoGroup = new THREE.Group();
torsoGroup.position.y = -0.52;
robot.add(torsoGroup);

const torsoProfile = (y) => {
    let w = 0.52; // base width
    let d = 0.162; // depth
    if (y > 0.68) { w = lerp(0.055, 0.12, ss(0.68, 0.82, y)); d = 0.042; } // neck
    else if (y > 0.48) { w = lerp(0.12, 0.48, ss(0.48, 0.68, y)); d = lerp(0.07, 0.13, ss(0.48, 0.68, y)); } // trapezius
    else if (y > 0.22) w = 0.535; // shoulders widest
    else if (y > -0.22) { w = 0.51; d = 0.165; } // chest broad
    else if (y > -0.55) { w = lerp(0.48, 0.51, ss(-0.55, -0.22, y)); d = lerp(0.152, 0.165, ss(-0.55, -0.22, y)); } // mid
    else { w = lerp(0.39, 0.48, ss(-0.85, -0.55, y)); d = lerp(0.115, 0.152, ss(-0.85, -0.55, y)); } // waist still broad
    return { w, d, n: y > 0.45 ? 2.05 : 2.2 };
};

const torsoGeo = (() => {
    const pos = [], uvs = [], idx = [];
    const stepsY = 92, stepsA = 64;
    for (let yi = 0; yi <= stepsY; yi++) {
        const t = yi / stepsY;
        const y = -0.88 + (1.65 * t);
        const p = torsoProfile(y);
        for (let ai = 0; ai <= stepsA; ai++) {
            const a = (ai / stepsA) * Math.PI * 2;
            const ca = Math.cos(a), sa = Math.sin(a);
            const e = 2 / p.n;
            const x = p.w * Math.sign(ca) * Math.pow(Math.abs(ca) + 1e-8, e);
            const z = p.d * Math.sign(sa) * Math.pow(Math.abs(sa) + 1e-8, e);
            pos.push(x, y, z);
            uvs.push(ai / stepsA, t);
        }
    }
    const stride = stepsA + 1;
    for (let yi = 0; yi < stepsY; yi++) {
        for (let ai = 0; ai < stepsA; ai++) {
            const a = yi * stride + ai;
            idx.push(a, a + stride, a + 1, a + 1, a + stride, a + stride + 1);
        }
    }
    const g = new THREE.BufferGeometry();
    g.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    g.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
    g.setIndex(idx);
    g.computeVertexNormals();
    return g;
})();

// Post sculpt for realistic torso
sculptGeo(torsoGeo, (v) => {
    // Pecs
    if (v.z > 0.05 && Math.abs(v.x) < 0.19 && v.y > -0.15 && v.y < 0.35) {
        v.z += gauss(v.x, 0, 0.09) * gauss(v.y, 0.12, 0.18) * 0.018;
    }
    // Shoulder rounding
    for (const side of [-1, 1]) {
        const dx = v.x - side * 0.46, dy = v.y - 0.42;
        const d = Math.sqrt(dx * dx + dy * dy * 1.8);
        if (d < 0.29 && v.y > 0.25) {
            const inf = gauss(d, 0, 0.14);
            v.y += inf * 0.038;
            v.z += inf * 0.022;
        }
    }
    // Central chest groove
    if (Math.abs(v.x) < 0.038 && v.z > 0.08 && v.y > -0.42 && v.y < 0.28) {
        v.z -= 0.011;
    }
    // Back spine channel
    if (v.z < -0.06 && Math.abs(v.x) < 0.21 && v.y > -0.75) {
        v.z += gauss(v.y, -0.32, 0.28) * 0.038;
    }
});

const torso = new THREE.Mesh(torsoGeo, shellMat);
torso.castShadow = torso.receiveShadow = true;
torsoGroup.add(torso);

// Central core glow
const core = new THREE.Mesh(new THREE.CylinderGeometry(0.038, 0.038, 0.42, 16), eyeCoreMat);
core.rotation.x = Math.PI / 2;
core.position.set(0, -0.28, 0.142);
torsoGroup.add(core);

// Torso seams
const torsoSeam = new THREE.Mesh(new THREE.BoxGeometry(0.004, 1.68, 0.004), jointMat);
torsoSeam.position.set(0, -0.48, 0.192);
torsoGroup.add(torsoSeam);

/* ====================== SPINE EXPOSED (back) ====================== */
const spineGroup = new THREE.Group();
spineGroup.position.set(0, -0.48, -0.055);
torsoGroup.add(spineGroup);
for (let i = 0; i < 13; i++) {
    const seg = new THREE.Mesh(new THREE.CylinderGeometry(0.029 - i * 0.0012, 0.036, 0.058, 10), i % 3 === 0 ? darkMat : boneMat);
    seg.position.y = -0.62 + i * 0.082;
    spineGroup.add(seg);
}

/* ====================== ARMS ====================== */
function createArm(side) {
    const s = side === 'left' ? -1 : 1;
    const arm = new THREE.Group();
    arm.position.set(s * 0.535, -0.14, 0.02);

    // Shoulder cap (white shell)
    const capGeo = new THREE.SphereGeometry(0.132, 24, 24);
    sculptGeo(capGeo, v => { if (v.y < 0) v.y *= 0.42; v.z *= 0.68; });
    const cap = new THREE.Mesh(capGeo, shellMat);
    arm.add(cap);

    // Ball joint
    const ball = new THREE.Mesh(new THREE.SphereGeometry(0.092, 24, 24), boneMat);
    arm.add(ball);

    // Shoulder rings
    const ring1 = new THREE.Mesh(new THREE.TorusGeometry(0.118, 0.006, 8, 24), jointMat);
    ring1.rotation.z = Math.PI / 2;
    arm.add(ring1);

    // Upper arm cables (8 irregular)
    const upperOffsets = [];
    for (let i = 0; i < 8; i++) {
        const ang = i * Math.PI * 2 / 8 + (i % 3) * 0.3;
        upperOffsets.push({
            x: Math.cos(ang) * 0.032,
            z: Math.sin(ang) * 0.032 + (Math.random() - 0.5) * 0.008
        });
    }
    upperOffsets.forEach(off => {
        const curve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(off.x, 0.02, off.z),
            new THREE.Vector3(off.x * 1.12, -0.22, off.z * 1.15),
            new THREE.Vector3(off.x * 1.08, -0.48, off.z * 1.09),
            new THREE.Vector3(off.x * 0.82, -0.62, off.z * 0.85)
        ], false, 'catmullrom', 0.38);
        const tube = new THREE.Mesh(new THREE.TubeGeometry(curve, 26, 0.0175, 7, false), cableMat);
        arm.add(tube);
    });

    // Elbow
    const elbow = new THREE.Mesh(new THREE.SphereGeometry(0.064, 20, 20), jointMat);
    elbow.position.set(0, -0.61, 0);
    arm.add(elbow);

    // Forearm pivot
    const forearmPivot = new THREE.Group();
    forearmPivot.position.set(0, -0.61, 0);
    forearmPivot.rotation.set(-0.92, 0, s * 0.08);
    arm.add(forearmPivot);

    // Forearm cables (6)
    const faOffsets = [];
    for (let i = 0; i < 6; i++) {
        const ang = i * Math.PI * 2 / 6;
        faOffsets.push({ x: Math.cos(ang) * 0.022, z: Math.sin(ang) * 0.022 });
    }
    faOffsets.forEach(off => {
        const curve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(off.x, 0, off.z),
            new THREE.Vector3(off.x * 1.1, -0.19, off.z * 1.12),
            new THREE.Vector3(off.x * 0.98, -0.38, off.z * 1.05),
            new THREE.Vector3(off.x * 0.65, -0.49, off.z * 0.78)
        ]);
        const tube = new THREE.Mesh(new THREE.TubeGeometry(curve, 22, 0.0145, 6, false), cableMat);
        forearmPivot.add(tube);
    });

    // Wrist
    const wrist = new THREE.Mesh(new THREE.CylinderGeometry(0.031, 0.033, 0.042, 12), jointMat);
    wrist.position.y = -0.46;
    forearmPivot.add(wrist);

    // Hand (resting pose)
    const hand = new THREE.Group();
    hand.position.set(s * 0.03, -0.54, -0.04);
    hand.rotation.set(0.25, s * 0.4, s * -0.35);
    forearmPivot.add(hand);

    const palm = new THREE.Mesh(new THREE.BoxGeometry(0.095, 0.028, 0.11), faceMat);
    sculptGeo(palm.geometry, v => {
        if (Math.abs(v.x) > 0.038 || Math.abs(v.z) > 0.042) v.y *= 0.65;
    });
    hand.add(palm);

    // Fingers (curled naturally)
    for (let f = 0; f < 4; f++) {
        const fg = new THREE.Group();
        fg.position.set(s * (-0.034 + f * 0.021), 0, -0.058);
        const len = [0.042, 0.055, 0.052, 0.039][f];
        const finger1 = new THREE.Mesh(new THREE.CylinderGeometry(0.0075, 0.006, len, 8), faceMat);
        finger1.rotation.x = 0.6 + f * 0.1;
        fg.add(finger1);
        const knuckle = new THREE.Mesh(new THREE.SphereGeometry(0.008, 8, 8), jointMat);
        knuckle.position.y = -len * 0.5;
        fg.add(knuckle);
        hand.add(fg);
    }
    // Thumb
    const thumb = new THREE.Group();
    thumb.position.set(s * 0.052, 0.01, -0.025);
    thumb.rotation.set(-0.6, 0, s * 1.1);
    const tSeg = new THREE.Mesh(new THREE.CylinderGeometry(0.009, 0.0075, 0.038, 8), faceMat);
    thumb.add(tSeg);
    hand.add(thumb);

    return { group: arm, forearmPivot };
}

const leftArm = createArm('left');
const rightArm = createArm('right');
robot.add(leftArm.group, rightArm.group);

/* ====================== LIGHTING ====================== */
scene.add(new THREE.AmbientLight(0x556677, 0.65));

const keyLight = new THREE.SpotLight(0xfffcee, 6.8, 0, 0.48, 0.6);
keyLight.position.set(2.2, 4.8, 3.8);
keyLight.castShadow = true;
keyLight.shadow.mapSize.set(2048, 2048);
keyLight.shadow.bias = -0.0004;
scene.add(keyLight);

const rimLight = new THREE.SpotLight(0xaaccff, 2.4, 0, 0.6, 0.8);
rimLight.position.set(-3.5, 2.8, -2.5);
scene.add(rimLight);

scene.add(new THREE.PointLight(0x88aaff, 1.1, 0, 2).position.set(0, 1.8, 2.5));

/* ====================== ANIMATION ====================== */
const slider = document.getElementById('tensionSlider');
const valEl = document.getElementById('val');
let tension = 0;
const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const targetTension = parseFloat(slider.value) / 100;
    tension = lerp(tension, targetTension, 0.065);

    valEl.textContent = Math.round(tension * 100) + '%';

    // Eye glow + heart
    const stressCol = new THREE.Color().lerpColors(new THREE.Color(0x88bbff), new THREE.Color(0xff4455), tension);
    eyeL.light.color.copy(stressCol);
    eyeR.light.color.copy(stressCol);
    eyeL.core.material.emissive.copy(stressCol);
    eyeR.core.material.emissive.copy(stressCol);
    eyeL.iris.material.emissive.copy(stressCol);
    eyeR.iris.material.emissive.copy(stressCol);

    // Head tracking + stress wobble
    const mouseInfluence = 0.18;
    headGroup.rotation.x = lerp(headGroup.rotation.x, -0.12 + tension * 0.22, 0.055);
    headGroup.rotation.y = lerp(headGroup.rotation.y, 0, 0.055); // calm center

    // Eye pivot follows head
    eyePivot.rotation.x = headGroup.rotation.x * -0.55;
    eyePivot.rotation.y = headGroup.rotation.y * -0.65;

    // Breathing
    const breath = Math.sin(clock.getElapsedTime() * (1.8 + tension * 2.2)) * (0.003 + tension * 0.007);
    torso.scale.setScalar(1 + breath);

    // Tension cable stretch
    leftArm.forearmPivot.rotation.x = lerp(-0.92, -1.05, tension);
    rightArm.forearmPivot.rotation.x = lerp(-0.92, -1.05, tension);

    controls.update();
    renderer.render(scene, camera);
}
animate();

/* ====================== RESIZE ====================== */
addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>