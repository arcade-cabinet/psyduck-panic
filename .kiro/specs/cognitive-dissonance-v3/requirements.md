# Requirements Document — Cognitive Dissonance v3.0

## Introduction

Cognitive Dissonance v3.0 is a comprehensive rebuild of the existing v2.0 Next.js + Babylon.js + Reactylon browser game into a cross-platform (web + Android + iOS) experience. The v3.0 spec transforms the current web-only codebase into a Reactylon Native application with dual AR/MR play modes (glasses room-scale and phone camera projection), elevated Miniplex ECS as the core architecture, WebGPU rendering on web with Babylon Native on mobile, WGSL shaders, XR hand tracking with haptics, procedural morph-based enemies with Yuka AI traits, and a crystalline-cube boss world-crush sequence. The buried seed continues to drive all procedural generation. No HUD ever — everything is diegetic. Build target: less than 5 MB gzipped.

## Glossary

- **Platter**: The heavy industrial black metal cylinder (18 cm depth, 1.2 m diameter) that serves as the primary interface. Contains keycaps on the rim, a garage-door slit, a MODE LEVER, and a recessed circular track for the Sphere.
- **Sphere**: The fragile 52 cm diameter glass sphere containing a living celestial nebula shader. Represents the AI mind. Sits in the Platter's recessed track.
- **Keycap**: A mechanical key on the Platter rim that the player holds to stabilize corruption patterns. Emerges via garage-door animation with GSAP.
- **MODE_LEVER**: A diegetic lever on the Platter rim that switches between glasses room-scale AR and phone camera projection AR modes. Uses GSAP resistance and gear-grind audio.
- **Tension**: A floating-point value (0.0–1.0) representing the AI mind's corruption level. At 1.0 the Sphere shatters.
- **Coherence**: An internal metric boosted by successful pattern stabilization, giving brief moments of clarity.
- **Corruption_Tendril**: A colored particle trail (SolidParticleSystem) that escapes from the Sphere center toward the rim. Matched by holding the corresponding Keycap.
- **Buried_Seed**: A deterministic seed (seedrandom/mulberry32) that drives all procedural generation — patterns, enemies, audio, visuals, level archetypes.
- **Dream**: A unique run generated by the Buried_Seed. Each dream selects a Level_Archetype and procedural parameters.
- **Level_Archetype**: A Miniplex archetype defining a gameplay mode — PlatterRotationDream, LeverTensionDream, KeySequenceDream, or CrystallineCubeBossDream.
- **Yuka_Enemy**: A procedural enemy driven by Yuka.js AI with one of seven morph traits, spawned when patterns are missed.
- **Morph_Trait**: One of seven enemy behavior types — NeonRaymarcher, TendrilBinder, PlatterCrusher, GlassShatterer, EchoRepeater, LeverSnatcher, SphereCorruptor — each with unique vertex morph shape and Yuka behavior.
- **Crystalline_Cube_Boss**: A boss enemy that performs a 5-phase world-crush GSAP timeline sequence, AR-anchored above the Platter.
- **Echo**: A ghost replay of a missed pattern that increases Tension.
- **Diegetic_GUI**: In-world UI elements (coherence ring, title engravings) that exist as 3D objects on the Platter or Sphere — never as HUD overlays.
- **AR_Session**: A WebXR immersive-ar session supporting either glasses room-scale (platter anchored to real surface, 26-joint hand interaction) or phone camera projection (platter projected via hit-test, screen touch on projected geometry).
- **Hand_Archetype**: A Miniplex entity representing a tracked XR hand with 26 joints, grip strength, pinch strength, and contact points.
- **DeviceQuality_System**: An adaptive quality system that adjusts particle counts, shader LOD, and post-process intensity based on device tier (low/mid/high).
- **PostProcess_Pipeline**: A tension-driven post-processing chain (bloom, vignette, chromatic aberration) applied via Babylon.js PostProcessRenderPipeline.
- **Mechanical_Degradation**: Diegetic visual feedback for WebGL2 fallback — platter rim hairline cracks, gear-binding sparks, lever resistance creep. No color/tone changes to the Sphere.
- **ImmersionAudio_Bridge**: The audio system bridging Expo SDK 55 expo-audio (native) with Tone.js (spatial score) for cross-platform sound.
- **SharedDreams_System**: Multiplayer anchor sync allowing multiple players to share the same AR-anchored Platter and Sphere.
- **Reactylon_Native**: The cross-platform rendering framework combining Reactylon (declarative Babylon.js + React) with Babylon Native for mobile and WebGPU for web.


## Requirements

### Requirement 1: Repository Cleanup and Cross-Platform Foundation

**User Story:** As a developer, I want to remove all legacy web-only files and establish a cross-platform project structure, so that the codebase supports web, Android, and iOS from a single source.

#### Acceptance Criteria

1. WHEN the migration begins, THE Build_System SHALL remove all Next.js-specific files (src/app/, next.config.ts, next-env.d.ts, postcss.config.mjs) and legacy files (index.html, index.html.old-canvas) from the repository.
2. WHEN the project is initialized, THE Build_System SHALL provide dual entry points: index.web.tsx for web (Metro + Expo web + WebGPU) and index.native.tsx for mobile (Metro + Babylon Native via Reactylon Native).
3. WHEN building for web, THE Build_System SHALL use Metro with Expo web support and target esnext for WebGPU support.
4. WHEN building for native, THE Build_System SHALL use Metro with Expo SDK 55 as a thin dev-client layer in front of Reactylon Native.
5. THE Build_System SHALL produce a production bundle of less than 5 MB gzipped across all platforms.
6. WHEN configuring TypeScript, THE Build_System SHALL target ES2022 with strict mode and path aliases for @babylonjs/core subpath imports only (tree-shakable, no barrel imports).
7. THE Build_System SHALL include babel-plugin-reactylon in the Babel configuration for declarative JSX reconciliation.

### Requirement 2: Engine Initialization and Rendering

**User Story:** As a developer, I want platform-conditional engine initialization with WebGPU on web and Babylon Native on mobile, so that the game renders optimally on each platform.

#### Acceptance Criteria

1. WHEN running on web, THE EngineInitializer SHALL detect WebGPU support via WebGPUEngine.IsSupportedAsync and create a WebGPUEngine if supported, falling back to a WebGL2 Engine otherwise.
2. WHEN running on native (Android/iOS), THE EngineInitializer SHALL use the Reactylon Native backend (Babylon Native with Metal/Vulkan/DirectX).
3. WHEN WebGPU is available, THE EngineInitializer SHALL initialize the engine asynchronously via initAsync with stencil buffer enabled.
4. WHEN WebGL2 fallback is active, THE Mechanical_Degradation system SHALL display diegetic platter degradation (rim hairline cracks, gear-binding sparks, lever resistance creep) without any color or tone changes to the Sphere.
5. THE EngineInitializer SHALL set hardware scaling level to 1 / devicePixelRatio for crisp rendering on all displays.

### Requirement 3: Adaptive Device Quality

**User Story:** As a player on varying hardware, I want the game to automatically adjust visual quality, so that I get smooth performance on my device.

#### Acceptance Criteria

1. WHEN the game starts, THE DeviceQuality_System SHALL detect the device tier (low, mid, high) based on available device memory and user agent heuristics.
2. WHILE the device tier is "high", THE DeviceQuality_System SHALL allow up to 5000 SolidParticle instances, full thin-film refraction on the Sphere, and full nebula shader complexity.
3. WHILE the device tier is "mid", THE DeviceQuality_System SHALL limit SolidParticle instances to 2500 and reduce post-process intensity.
4. WHILE the device tier is "low", THE DeviceQuality_System SHALL limit SolidParticle instances to 800, disable thin-film refraction, and simplify the nebula shader.
5. THE DeviceQuality_System SHALL target a minimum of 45 frames per second on supported devices (iPhone 12+ / A14+, Snapdragon 888+ with 6 GB RAM).

### Requirement 4: Miniplex ECS Architecture

**User Story:** As a developer, I want Miniplex ECS elevated as the core architecture with level archetypes, hand archetypes, AR archetypes, and enemy archetypes, so that all game entities are managed through a unified system.

#### Acceptance Criteria

1. THE ECS_World SHALL define Level_Archetype entities: PlatterRotationDream (rotation mechanics), LeverTensionDream (lever resistance), KeySequenceDream (keycap pattern sequences), and CrystallineCubeBossDream (boss encounter).
2. THE ECS_World SHALL define Hand_Archetype entities: LeftHand and RightHand, each with 26 joints, gripStrength, pinchStrength, and contactPoints components.
3. THE ECS_World SHALL define AR_Archetype entities: WorldAnchoredPlatter (glasses room-scale), ProjectedPlatter (phone camera projection), and ARSphere.
4. THE ECS_World SHALL define Enemy_Archetype entities: YukaEnemy with morphTarget, currentTrait, morphProgress, and anchor components.
5. THE ECS_World SHALL define Boss_Archetype entities: CrystallineCubeBoss with crushPhase, health, and worldImpact components.
6. WHEN a new Dream is started, THE ECS_World SHALL spawn the appropriate Level_Archetype entity based on the Buried_Seed hash (seedHash modulo 4 selects the archetype).
7. THE ECS_World SHALL use miniplex-react bindings (useQuery) for reactive system queries across all archetypes.

### Requirement 5: Tension System

**User Story:** As a player, I want the AI mind's corruption to escalate realistically with an over-stabilization risk mechanic, so that gameplay has strategic depth beyond simple pattern matching.

#### Acceptance Criteria

1. THE TensionSystem SHALL maintain a currentTension value clamped between 0.0 and 0.999.
2. WHEN a pattern is missed, THE TensionSystem SHALL increase tension by a configurable amount scaled by the current Level_Archetype parameters.
3. WHEN a Keycap is held successfully, THE TensionSystem SHALL decrease tension by 0.018 multiplied by the hand grip strength (or 1.0 for keyboard input).
4. WHEN tension drops below 0.05, THE TensionSystem SHALL apply an over-stabilization rebound with a 2% probability, increasing tension by 0.12.
5. WHEN tension changes, THE TensionSystem SHALL propagate the new value to the ImmersionAudio_Bridge, the Mechanical_Degradation system, and the ProceduralMorph_System.
6. WHEN tension reaches 0.999, THE TensionSystem SHALL trigger the sphere shatter sequence and transition to the "COGNITION SHATTERED" game-over state.

### Requirement 6: Pattern Stabilization System

**User Story:** As a player, I want to hold matching colored keycaps to pull corruption patterns back into the sphere, so that I can delay the AI mind's breakdown.

#### Acceptance Criteria

1. WHEN a player holds a Keycap matching a Corruption_Tendril color, THE PatternStabilization_System SHALL retract the corresponding tendril toward the Sphere center.
2. WHEN a Keycap is held, THE PatternStabilization_System SHALL decrease tension via the TensionSystem.
3. WHEN a pattern reaches the Platter rim without being stabilized, THE PatternStabilization_System SHALL trigger an Echo (ghost replay) and spawn a Yuka_Enemy.
4. WHEN all required Keycaps for a pattern set are held simultaneously, THE PatternStabilization_System SHALL grant a coherence bonus (0.09 tension decrease).
5. THE PatternStabilization_System SHALL apply physics impostors (mass 0.3, restitution 0.1) to all Keycaps for realistic hold resistance.
6. WHEN a Keycap is released, THE PatternStabilization_System SHALL remove the active stabilization after the configured hold duration.

### Requirement 7: Corruption Tendril System

**User Story:** As a player, I want to see colored tendrils escaping from the sphere, so that I have clear visual feedback of the AI mind's corruption state.

#### Acceptance Criteria

1. THE CorruptionTendril_System SHALL use a SolidParticleSystem with up to 24 tendril shapes attached to the Sphere mesh.
2. WHEN tension exceeds 0.3, THE CorruptionTendril_System SHALL begin spawning tendrils from the Sphere center toward the rim at a rate proportional to tension.
3. WHEN a matching Keycap is held, THE CorruptionTendril_System SHALL retract the corresponding tendril and decrease tension by 0.03.
4. THE CorruptionTendril_System SHALL color tendrils using the Buried_Seed-derived palette for the current Dream.

### Requirement 8: Mechanical Animation System

**User Story:** As a player, I want satisfying mechanical animations for the platter, garage-door slit, lever, and keycap emergence, so that the industrial aesthetic feels weighty and real.

#### Acceptance Criteria

1. THE MechanicalAnimation_System SHALL use GSAP timelines with CustomEase ("heavyMechanical") for all platter slit, lever, and keycap animations.
2. WHEN the game starts, THE MechanicalAnimation_System SHALL animate the garage-door slit open (top slides up, bottom slides down) with staggered timing to simulate weight difference.
3. WHEN the MODE_LEVER is pulled, THE MechanicalAnimation_System SHALL animate the lever with GSAP resistance (back.out ease) and trigger the AR mode switch via the AR_Session.
4. WHEN a Keycap emerges, THE MechanicalAnimation_System SHALL animate the emergence along a curved MotionPath from the Platter interior to the rim position.
5. THE MechanicalAnimation_System SHALL register the MODE_LEVER with a callback for AR mode switching.

### Requirement 9: Sphere Nebula Material

**User Story:** As a player, I want the glass sphere to contain a living celestial nebula that degrades from calm blue to violent red as tension rises, so that the AI mind's state is visually communicated.

#### Acceptance Criteria

1. THE SphereNebula_Material SHALL extend PBRMaterial with sub-surface refraction (intensity 0.95), zero metallic, and near-zero roughness for glass appearance.
2. THE SphereNebula_Material SHALL include a custom shader (WGSL primary with GLSL fallback) that renders a celestial nebula with turbulence and static noise.
3. WHEN tension changes, THE SphereNebula_Material SHALL interpolate the nebula color from calm blue (0.1, 0.6, 1.0) to violent red (1.0, 0.3, 0.1) proportional to the tension value.
4. THE SphereNebula_Material SHALL apply a breathing scale pulse (sinusoidal at 1.8 Hz) with amplitude proportional to tension (0.03 at max).
5. WHEN tension exceeds 0.7, THE SphereNebula_Material SHALL add visible static jitter to the nebula proportional to tension.

### Requirement 10: Mechanical Platter Construction

**User Story:** As a player, I want a heavy industrial platter with garage-door slit, MODE LEVER, keycaps on the rim, and a recessed track for the sphere, so that the interface feels like a real mechanical device.

#### Acceptance Criteria

1. THE MechanicalPlatter SHALL be a cylinder mesh (height 0.18 m, diameter 1.2 m) with PBR material (metallic 0.9, roughness 0.4, near-black albedo).
2. THE MechanicalPlatter SHALL include a recessed circular torus track (diameter 0.8 m, thickness 0.04 m) for the Sphere.
3. THE MechanicalPlatter SHALL include a garage-door slit (top and bottom box meshes, width 0.9 m) that opens via GSAP animation.
4. THE MechanicalPlatter SHALL include a MODE_LEVER box mesh (0.08 × 0.12 × 0.04 m) positioned on the rim at x=0.55.
5. THE MechanicalPlatter SHALL include at least 14 Keycap box meshes (0.08 × 0.04 × 0.08 m each) distributed around the rim using polar coordinates.
6. THE MechanicalPlatter SHALL include a 52 cm diameter Sphere with glass PBR material parented to the Platter via the recessed track.


### Requirement 11: Procedural Morph-Based Enemies

**User Story:** As a player, I want enemies that procedurally morph based on the buried seed and tension, with seven distinct behavioral traits, so that each run presents unique combat challenges.

#### Acceptance Criteria

1. THE ProceduralMorph_System SHALL use Babylon.js MorphTargetManager with GPU vertex morphing to deform enemy meshes in real time.
2. WHEN a Yuka_Enemy spawns, THE ProceduralMorph_System SHALL assign one of seven Morph_Traits based on the Buried_Seed hash: NeonRaymarcher (fast neon trails, evades key holds), TendrilBinder (extends corruption tendrils, increases tension 2x faster), PlatterCrusher (heavy morph that flattens keycaps), GlassShatterer (fragile high-speed morph, death spawns glass-shard particles), EchoRepeater (duplicates self up to 3 copies), LeverSnatcher (targets MODE_LEVER, forces unwanted AR mode switch), SphereCorruptor (morphs into sphere-like blob, accelerates breathing corruption).
3. WHEN tension changes, THE ProceduralMorph_System SHALL adjust morph speed and scale proportionally (morphProgress lerps from 0 to 1 based on tension × 1.5).
4. WHEN a player counters a Yuka_Enemy (via hand grip or phone touch), THE ProceduralMorph_System SHALL reduce morphProgress by gripStrength × 0.15, and dispose the enemy when morphProgress reaches 0.
5. THE DeviceQuality_System SHALL cap active morph targets at 12 for high tier, 8 for mid tier, and 4 for low tier.

### Requirement 12: Crystalline-Cube Boss System

**User Story:** As a player, I want a dramatic boss encounter where a crystalline cube descends and tries to crush the platter, so that high-tension gameplay has climactic moments.

#### Acceptance Criteria

1. WHEN tension reaches 0.92 or 3 patterns are missed consecutively, THE CrystallineCubeBoss_System SHALL spawn a CrystallineCubeBoss entity anchored above the Platter.
2. THE CrystallineCubeBoss_System SHALL execute a 5-phase GSAP timeline: emerge (cube appears above platter), descend (2.5s power2.in ease), slam prep (scaling 1.3x/0.7y/1.3z over 0.8s), impact (0.4s power4.out to platter surface), and resolve (counter check).
3. WHEN the impact phase completes, THE CrystallineCubeBoss_System SHALL trigger Mechanical_Degradation world impact, set tension to 0.98 via the TensionSystem, and fire a heavy haptic pulse.
4. WHILE the boss is in counter phase, THE CrystallineCubeBoss_System SHALL reduce boss health by totalGripStrength × 0.012 per frame.
5. WHEN boss health reaches 0, THE CrystallineCubeBoss_System SHALL shatter the boss into Yuka_Enemy shards and dispose the boss mesh.
6. IF the player fails to counter (boss health remains above 0.3 after resolve), THEN THE CrystallineCubeBoss_System SHALL trigger permanent platter deformation and set tension to 0.999.

### Requirement 13: Dual AR/MR Modes

**User Story:** As a player, I want to play either with AR glasses (platter anchored in my room, hands-free) or through my phone camera (platter projected into my room, touch controls), so that I can choose the immersion level that suits my device.

#### Acceptance Criteria

1. WHEN the AR session starts, THE AR_Session SHALL detect the device type (phone/tablet vs glasses) using Expo Device API and select the appropriate mode.
2. WHILE in glasses room-scale mode, THE AR_Session SHALL anchor the Platter to a real-world horizontal plane via WebXRAnchor with plane detection, and enable 26-joint hand interaction.
3. WHILE in phone camera projection mode, THE AR_Session SHALL enable tap-to-place for the Platter via WebXR hit-test, and route all input through the PhoneProjectionTouch_System (screen raycast to projected geometry).
4. WHEN the MODE_LEVER is pulled, THE AR_Session SHALL switch between glasses and phone modes, re-anchoring the Platter and switching input systems accordingly.
5. WHEN the Platter is placed in AR, THE AR_Session SHALL parent the Sphere to the Platter via the recessed track constraint.
6. IF no AR support is detected, THEN THE AR_Session SHALL fall back to screen mode with the Platter floating in a dark void.

### Requirement 14: XR Hand Tracking and Haptics

**User Story:** As a player using AR glasses, I want to physically grasp keycaps, pull the lever, and cradle the sphere with my tracked hands, so that the interaction feels tangible and immersive.

#### Acceptance Criteria

1. WHEN an XR session starts with hand-tracking support, THE XR_Manager SHALL create LeftHand and RightHand Miniplex entities with 26 joints each from WebXRHandTracking.
2. WHEN finger joints are near a Keycap, THE HandInteraction_System SHALL trigger PatternStabilization_System.holdKey with pinch strength as the grip parameter.
3. WHEN a palm grips the MODE_LEVER, THE HandInteraction_System SHALL trigger MechanicalAnimation_System.pullLever with grip strength as the resistance parameter.
4. WHEN joints cradle the Sphere, THE HandInteraction_System SHALL pulse the TensionSystem by 0.02 per frame.
5. WHEN mechanical contact occurs, THE MechanicalHaptics_System SHALL trigger haptic feedback via expo-haptics on native (ImpactFeedbackStyle.Heavy for lever, Medium for keycap, Light for sphere) and navigator.vibrate on web.
6. THE MechanicalHaptics_System SHALL sync haptic intensity to the current tension value via a Tone.js brown noise rumble (volume = tension × -18 dB).

### Requirement 15: Phone Projection Touch System

**User Story:** As a player using phone camera AR, I want to tap and drag on the projected platter rim, keycaps, and lever through my phone screen, so that I can play the game through camera projection.

#### Acceptance Criteria

1. WHEN the phone projection mode is active, THE PhoneProjectionTouch_System SHALL register pointer-down and pointer-move observers on the Babylon.js scene.
2. WHEN a touch hits a projected Keycap mesh, THE PhoneProjectionTouch_System SHALL call PatternStabilization_System.holdKey with the keycap name.
3. WHEN a touch hits the projected MODE_LEVER mesh, THE PhoneProjectionTouch_System SHALL call MechanicalAnimation_System.pullLever with the pick distance.
4. WHEN a touch hits the projected Platter rim, THE PhoneProjectionTouch_System SHALL call MechanicalAnimation_System.rotatePlatter with the x-coordinate of the pick point.

### Requirement 16: AR Occlusion Shader

**User Story:** As a player in AR, I want virtual objects to be properly occluded by real-world surfaces, so that the platter and sphere feel like they exist in my physical space.

#### Acceptance Criteria

1. THE AROcclusion_Material SHALL extend PBRMaterial with environment-depth texture binding from WebXR Depth Sensing (WebXREnvironmentDepth feature).
2. WHEN environment-depth data is available (iOS 26+, Quest 3+, Vision Pro), THE AROcclusion_Material SHALL discard fragments where virtual depth exceeds real depth plus a 0.01 threshold.
3. IF environment-depth is not available, THEN THE AROcclusion_Material SHALL fall back to stencil buffer plus DepthRenderer for occlusion.
4. THE AROcclusion_Material SHALL be applied to all virtual meshes: Platter, Sphere, Keycaps, MODE_LEVER, Yuka_Enemies, CrystallineCubeBoss, and particles.

### Requirement 17: Audio System

**User Story:** As a player, I want an adaptive spatial audio score that evolves from calm to frantic to shattered as tension rises, so that the soundscape reinforces the AI mind's deteriorating state.

#### Acceptance Criteria

1. THE ImmersionAudio_Bridge SHALL initialize Tone.js as the core score engine with a reverb (decay 4s, wet 0.6) connected to the destination.
2. WHEN tension changes, THE ImmersionAudio_Bridge SHALL adjust reverb wet from 0.3 (calm) to 0.9 (frantic) proportional to tension.
3. THE ImmersionAudio_Bridge SHALL use Expo SDK 55 expo-audio for native AudioContext bridging (playsInSilentModeIOS: true, staysActiveInBackground: true).
4. WHEN mechanical contact occurs (keycap hold, lever pull, platter rotation), THE SpatialAudio_System SHALL trigger event-driven procedural SFX positioned at the contact point.
5. THE SpatialAudio_System SHALL use Buried_Seed-derived parameters for BPM, swing, and sequence patterns to ensure deterministic audio evolution per Dream.

### Requirement 18: Post-Process Corruption Pipeline

**User Story:** As a player, I want the screen to visually degrade with bloom, vignette, and chromatic aberration as tension rises, so that the corruption feels all-encompassing.

#### Acceptance Criteria

1. THE PostProcess_Pipeline SHALL create a PostProcessRenderPipeline with bloom, vignette, and chromatic aberration effects attached to the active camera.
2. WHEN tension changes, THE PostProcess_Pipeline SHALL scale bloom weight to tension × 0.8, vignette weight to tension × 0.6, and chromatic aberration amount to tension × 0.04.
3. THE PostProcess_Pipeline SHALL respect DeviceQuality_System tier settings for effect intensity.

### Requirement 19: Diegetic GUI and Title System

**User Story:** As a player, I want all UI to be part of the physical machine (coherence ring, title engravings) with no HUD overlays, so that immersion is never broken.

#### Acceptance Criteria

1. THE DiegeticCoherence_Ring SHALL be a torus mesh (diameter 0.58 m, thickness 0.01 m, 64 tessellation) parented to the Sphere with emissive PBR material.
2. WHEN tension changes, THE DiegeticCoherence_Ring SHALL shift emissive color from blue-green (low tension) to red (high tension) and scale by 1.0 + tension × 0.2.
3. WHEN the game starts, THE TitleAndGameOver_System SHALL display "COGNITIVE DISSONANCE" as a plane mesh with text texture etched on the Platter rim, animated in via GSAP back.out ease.
4. WHEN the Sphere shatters, THE TitleAndGameOver_System SHALL display "COGNITION SHATTERED" as a plane mesh parented to the Sphere with red static text, accompanied by a GSAP yoyo scaling animation (3 repeats).
5. THE game SHALL contain zero HUD overlays, zero HTML text overlays, and zero non-diegetic UI elements at any point during gameplay.

### Requirement 20: Echo System

**User Story:** As a player, I want missed patterns to replay as ghostly echoes that increase tension, so that mistakes have lingering consequences.

#### Acceptance Criteria

1. WHEN a pattern reaches the Platter rim without stabilization, THE Echo_System SHALL spawn a translucent ghost Keycap mesh (alpha 0.4, red-tinted) at the missed position.
2. THE Echo_System SHALL auto-dispose ghost meshes after 1800 ms.
3. WHEN an Echo spawns, THE Echo_System SHALL increase tension by 0.035 and trigger a medium haptic pulse.
4. THE Echo_System SHALL prevent duplicate echoes for the same key (one active echo per key maximum).

### Requirement 21: Mechanical Degradation System

**User Story:** As a player on WebGL2 fallback, I want diegetic visual feedback of reduced quality through platter degradation, so that the fallback feels intentional rather than broken.

#### Acceptance Criteria

1. WHILE WebGL2 fallback is active, THE Mechanical_Degradation system SHALL incrementally increase platter rim crack intensity via PBR normal maps (up to 0.8 intensity).
2. WHILE WebGL2 fallback is active, THE Mechanical_Degradation system SHALL add micro-jitter to platter rotation (sinusoidal at 200 ms period, 0.0005 amplitude).
3. WHILE WebGL2 fallback is active, THE Mechanical_Degradation system SHALL increase lever resistance in GSAP timelines.
4. THE Mechanical_Degradation system SHALL apply zero color or tone changes to the Sphere nebula shader under any fallback condition.

### Requirement 22: Accessibility and Voice Commands

**User Story:** As a player with limited mobility, I want to stabilize patterns using voice commands and receive adaptive haptic feedback, so that the game is accessible without requiring precise finger movements.

#### Acceptance Criteria

1. WHEN a voice command matching a Keycap letter is received, THE DiegeticAccessibility_System SHALL call PatternStabilization_System.holdKey with the recognized letter and a hold duration of 1200 ms.
2. THE DiegeticAccessibility_System SHALL use expo-speech for voice command recognition and spoken feedback ("Stabilizing [key]" at rate 0.9).
3. WHEN tension exceeds 0.7, THE DiegeticAccessibility_System SHALL trigger error-level haptic notifications via expo-haptics.
4. WHEN tension is between 0.4 and 0.7, THE DiegeticAccessibility_System SHALL trigger medium-impact haptic feedback via expo-haptics.

### Requirement 23: Shared Dreams Multiplayer

**User Story:** As a player, I want to share my AR-anchored platter and sphere with another player, so that we can cooperatively hold the AI mind together.

#### Acceptance Criteria

1. WHEN a local AR anchor is established, THE SharedDreams_System SHALL provide a method to share the anchor with a peer via a peer ID.
2. WHEN a shared anchor is received, THE SharedDreams_System SHALL render a remote platter with a faint glass-shard overlay at the shared anchor position.
3. WHEN shared corruption occurs, THE SharedDreams_System SHALL increase local tension by 0.01 to reflect shared state.

### Requirement 24: Production Packaging

**User Story:** As a developer, I want the app packaged under the arcade_cabinet.cognitive_dissonance namespace with proper AR entitlements, so that it can be submitted to app stores.

#### Acceptance Criteria

1. THE app.json SHALL set the iOS bundleIdentifier to "arcade.cabinet.cognitivedissonance" and the Android package to "arcade.cabinet.cognitivedissonance".
2. THE app.json SHALL include AR entitlements: NSCameraUsageDescription, NSMicrophoneUsageDescription, and UIRequiredDeviceCapabilities (arkit, hand-tracking) for iOS.
3. THE app.json SHALL include CAMERA and RECORD_AUDIO permissions for Android.
4. THE app.json SHALL include expo-ar, expo-haptics, expo-speech, expo-dev-client, and expo-build-properties plugins.
5. THE eas.json SHALL define development, preview, and production build profiles with autoIncrement enabled for production.

### Requirement 25: Targeted Repository Cleanup

**User Story:** As a developer, I want all legacy v2.0 Next.js/web-only files surgically removed and the existing src/ code replaced with the v3.0 Grok-doc codebase, so that no dead code or conflicting configurations remain.

#### Acceptance Criteria

1. WHEN cleanup begins, THE Build_System SHALL delete all Next.js-specific files: src/app/ (layout.tsx, page.tsx, globals.css), next.config.ts, next-env.d.ts, postcss.config.mjs.
2. WHEN cleanup begins, THE Build_System SHALL delete all legacy web-only files: index.html, index.html.old-canvas, .next/ build cache.
3. WHEN cleanup begins, THE Build_System SHALL delete all v2.0 test infrastructure: e2e/ directory, vitest.config.ts, playwright.config.ts, src/lib/__tests__/, src/store/__tests__/.
4. WHEN cleanup begins, THE Build_System SHALL delete the src/components/ui/ directory (Tailwind/shadcn remnants).
5. WHEN cleanup begins, THE Build_System SHALL replace all existing src/components/*.tsx files with the v3.0 implementations from the Grok doc codebase (not preserve them).
6. WHEN cleanup begins, THE Build_System SHALL replace src/game/world.ts, src/lib/*.ts, src/store/*.ts, and src/types/*.ts with v3.0 implementations.
7. WHEN cleanup begins, THE Build_System SHALL replace the existing android/ and ios/ directories with fresh Reactylon Native template output (preserving .git/).
8. WHEN cleanup begins, THE Build_System SHALL delete the native/ directory (incomplete v2.0 stub).
9. WHEN cleanup begins, THE Build_System SHALL delete sonar-project.properties (SonarCloud config for v2.0 Next.js).
10. WHEN cleanup begins, THE Build_System SHALL update .gitignore to include Reactylon Native / Expo / Metro ignores (android/build, ios/Pods, *.xcworkspace, .expo/, metro-cache/).

### Requirement 26: GitHub Actions CI/CD Migration

**User Story:** As a developer, I want the CI/CD pipelines updated from Next.js/Playwright/Vitest to Metro/Expo web builds, Metro native builds, and EAS cloud builds, so that all platforms are tested and deployed automatically.

#### Acceptance Criteria

1. WHEN the CI workflow runs, THE CI_Pipeline SHALL execute: Biome lint, TypeScript type-check (tsc --noEmit), and Jest unit tests for the v3.0 codebase.
2. WHEN the CI workflow runs, THE CI_Pipeline SHALL build the web target via Expo web export (pnpm build:web) and verify the output is under 5 MB gzipped.
3. WHEN the CI workflow runs, THE CI_Pipeline SHALL build the Android debug APK via Gradle (./gradlew assembleDebug) in the android/ directory.
4. WHEN the CD workflow runs on main, THE CD_Pipeline SHALL deploy the Expo web build to GitHub Pages (replacing the Next.js static export).
5. WHEN the CD workflow runs on main, THE CD_Pipeline SHALL build and upload Android debug APKs as release artifacts.
6. WHEN the CD workflow runs on main, THE CD_Pipeline SHALL trigger EAS Build for iOS (preview profile) if EAS credentials are configured.
7. THE CI_Pipeline SHALL remove all Playwright E2E test steps (replaced by Jest + future Detox/Maestro for native).
8. THE CI_Pipeline SHALL remove the SonarCloud scan step and CodeQL JavaScript analysis (replaced by Biome).
9. THE .github/actions/setup/action.yml SHALL be updated to use pnpm install with the v3.0 lockfile.
10. THE automerge.yml workflow SHALL remain functional with updated CI job references.

### Requirement 27: Dependabot Configuration Migration

**User Story:** As a developer, I want Dependabot groups updated to track the v3.0 dependency ecosystem, so that automated updates cover Expo, Babylon.js, Reactylon, and Metro packages.

#### Acceptance Criteria

1. THE dependabot.yml SHALL remove package groups for: capacitor, and testing (Playwright, Vitest, jsdom).
2. THE dependabot.yml SHALL add package groups for: babylonjs (@babylonjs/*), reactylon (reactylon), expo (expo-*), and react-native (react-native, react-native-*).
3. THE dependabot.yml SHALL retain the react group (react, react-dom, @types/react) and dev-tools group (@biomejs/biome).
4. THE dependabot.yml SHALL retain the github-actions ecosystem configuration unchanged.

### Requirement 28: Documentation Updates

**User Story:** As a developer, I want all project documentation updated to reflect the v3.0 cross-platform architecture, so that contributors and agents have accurate context.

#### Acceptance Criteria

1. THE docs/ARCHITECTURE.md SHALL be rewritten to describe the v3.0 Reactylon Native + Metro architecture, replacing all Next.js/Turbopack references.
2. THE docs/DEPLOYMENT.md SHALL be rewritten to describe Expo web deployment, EAS Build for iOS/Android, and Metro dev-client workflow, replacing Next.js deployment instructions.
3. THE docs/GITHUB_ACTIONS.md SHALL be rewritten to describe the migrated CI/CD pipelines (Expo web build, Gradle APK, EAS Build), replacing Playwright E2E matrix and Next.js build references.
4. THE docs/AUTOMATED_WORKFLOWS.md SHALL be updated to reflect the new Dependabot groups and any changes to automerge conditions.
5. THE docs/DESIGN.md SHALL be updated to include v3.0 visual elements: dual AR/MR modes, morph enemies, crystalline-cube boss, MODE_LEVER, AR occlusion.
6. THE docs/DESIGN_SYSTEM.md SHALL be updated to include v3.0 materials: WGSL nebula shader parameters, AR occlusion material, morph enemy materials, boss crystalline material.
7. THE README.md SHALL be rewritten to describe the v3.0 cross-platform project: Metro entry points for web + native, pnpm build:web / pnpm android / pnpm ios commands, v3.0 architecture overview.
8. THE AGENTS.md SHALL be rewritten to describe the v3.0 architecture, tech context, commands, file structure, and active decisions (replacing all Next.js/Turbopack/Playwright references).
9. THE CLAUDE.md SHALL be rewritten to describe v3.0 conventions, commands, and architecture.
10. THE DEVELOPMENT.md SHALL be rewritten to describe v3.0 development workflow: Metro dev server (all platforms), Android Studio / Xcode setup, testing with Jest.
11. THE TESTING.md SHALL be rewritten to describe v3.0 testing strategy: Jest unit tests, property-based tests for core systems, future Detox/Maestro for native E2E.
12. THE .github/copilot-instructions.md SHALL be rewritten to describe the v3.0 stack and conventions.
13. THE .gemini/prompts/*.toml files SHALL be updated to reference v3.0 architecture and tooling.

### Requirement 29: Test Infrastructure Migration

**User Story:** As a developer, I want the test infrastructure migrated from Vitest to Jest for unit/property-based tests, Playwright retained for web E2E, and Maestro added for mobile E2E on Android/iOS, so that all platforms have comprehensive automated test coverage.

#### Acceptance Criteria

1. WHEN the test migration begins, THE Test_Infrastructure SHALL replace Vitest with Jest (jest + ts-jest + @types/jest) as the unit and property-based test runner.
2. THE Test_Infrastructure SHALL configure Jest with ts-jest transform, moduleNameMapper for @babylonjs/core subpath aliases, and testEnvironment set to "node" (no jsdom — game logic is headless-testable).
3. THE Test_Infrastructure SHALL migrate all existing unit tests from src/lib/__tests__/ and src/store/__tests__/ to Jest syntax (describe/it/expect), updating any Vitest-specific APIs (vi.fn → jest.fn, vi.spyOn → jest.spyOn).
4. THE Test_Infrastructure SHALL add fast-check as the property-based testing library, integrated with Jest via fc.assert inside it() blocks.
5. THE Test_Infrastructure SHALL include property-based tests for core systems: TensionSystem (tension clamping, over-stabilization rebound probability), PatternStabilizationSystem (coherence bonus on full match), CorruptionTendrilSystem (spawn rate proportional to tension), and ECS World (seed-to-archetype determinism).
6. THE Test_Infrastructure SHALL retain Playwright for web E2E testing, with the config updated to target the Expo web dev server (webServer.command: "pnpm web") instead of the Next.js dev server.
7. THE Test_Infrastructure SHALL migrate existing Playwright E2E tests (e2e/*.spec.ts) to work with the Expo web build, updating any Next.js-specific selectors or routes.
8. THE Test_Infrastructure SHALL add Maestro as the mobile E2E testing framework with flow YAML files for Android and iOS.
9. THE Test_Infrastructure SHALL include Maestro flows for: app launch and engine initialization, pattern stabilization gameplay loop, AR session start (mocked camera feed), and game-over shatter sequence.
10. THE CI_Pipeline SHALL run Jest unit tests in the code-quality job, Playwright web E2E in a dedicated web-e2e job, and Maestro mobile E2E in a dedicated mobile-e2e job (using macos-latest runner with Android emulator).
11. THE Test_Infrastructure SHALL configure Jest coverage output in lcov format at coverage/lcov.info for CI consumption.
12. THE Test_Infrastructure SHALL remove all Vitest dependencies (vitest, @vitest/coverage-v8, @vitest/ui) and configuration files (vitest.config.ts, vitest.workspace.ts if present).

### Requirement 30: Level Archetype Gameplay Mechanics

**User Story:** As a player, I want each Dream to play fundamentally differently based on the buried seed's archetype selection, so that every run feels mechanically distinct and the platter/keycap/lever architecture is fully exploited.

#### Acceptance Criteria

1. WHEN a PlatterRotationDream is spawned, THE DreamTypeHandler SHALL activate platter rotation mechanics: the platter physically rotates at a seed-derived RPM (2–8 RPM), keycaps orbit with the platter, and the player must hold keycaps as they pass their reach zone (a 90° arc in front of the camera).
2. WHILE PlatterRotationDream is active, THE PatternStabilization_System SHALL require the player to time keycap holds to the rotation cycle — holding a keycap outside the reach zone has no effect, and the rotation speed increases logarithmically with tension.
3. WHEN a LeverTensionDream is spawned, THE DreamTypeHandler SHALL activate lever-centric mechanics: the MODE_LEVER becomes the primary input, corruption tendrils target the lever instead of keycaps, and the player must hold the lever at specific resistance positions (0.0–1.0 range) to match corruption frequencies.
4. WHILE LeverTensionDream is active, THE MechanicalAnimation_System SHALL animate the garage-door slit opening and closing rhythmically (seed-derived period 1.5–4s), and the player must time lever pulls to the slit cycle to stabilize patterns that emerge from the slit.
5. WHEN a KeySequenceDream is spawned, THE DreamTypeHandler SHALL activate sequence-based mechanics: corruption patterns require specific multi-key sequences (2–5 keys in order) rather than single holds, and the sequence complexity increases with tension.
6. WHILE KeySequenceDream is active, THE PatternStabilization_System SHALL display the required sequence as ghost keycap highlights on the platter rim, and the player must press keys in the correct order within a seed-derived time window (800ms–2000ms per key).
7. WHEN a CrystallineCubeBossDream is spawned, THE DreamTypeHandler SHALL immediately enter boss encounter mode: the platter locks rotation, all keycaps retract, and the crystalline-cube boss descends with a unique 5-phase GSAP timeline that differs from the standard boss spawn.
8. WHILE CrystallineCubeBossDream is active, THE CrystallineCubeBoss_System SHALL require the player to use both lever resistance AND keycap holds simultaneously to counter the boss (lever controls shield angle, keycaps fire stabilization pulses).
9. THE DreamTypeHandler SHALL transition between archetype behaviors cleanly when a new Dream is spawned (dispose previous archetype systems, initialize new ones, preserve tension state).

### Requirement 31: Keyboard Input System

**User Story:** As a web/desktop player, I want to use my physical keyboard to hold keycaps, pull the lever, and interact with the platter, so that I can play the game without XR or touch hardware.

#### Acceptance Criteria

1. WHEN a keyboard key matching a platter Keycap letter is pressed, THE KeyboardInput_System SHALL call PatternStabilization_System.holdKey with the key name, a hold duration equal to the keydown duration, and grip strength 1.0.
2. WHEN a keyboard key is released, THE KeyboardInput_System SHALL call PatternStabilization_System.releaseKey to end the active stabilization.
3. THE KeyboardInput_System SHALL support simultaneous multi-key holds (up to 6 keys) for pattern set matching.
4. WHEN the spacebar is pressed, THE KeyboardInput_System SHALL call MechanicalAnimation_System.pullLever with position proportional to hold duration (0.0 at press, 1.0 at 800ms hold).
5. WHEN the Enter key is pressed during the title phase, THE KeyboardInput_System SHALL transition the game to the playing phase.
6. THE KeyboardInput_System SHALL map arrow keys to platter rotation (left/right) for PlatterRotationDream archetype interaction.
7. THE KeyboardInput_System SHALL be disabled when an XR session is active or phone projection mode is active.

### Requirement 32: System Orchestration

**User Story:** As a developer, I want a defined system initialization and update order, so that cross-system dependencies (tension → morph, pattern → echo, etc.) are resolved correctly every frame.

#### Acceptance Criteria

1. THE SystemOrchestrator SHALL initialize systems in this order: EngineInitializer → SceneManager → DeviceQuality → ECS World → MechanicalPlatter → SphereNebulaMaterial → DiegeticCoherenceRing → TensionSystem → DifficultyScalingSystem → PatternStabilizationSystem → CorruptionTendrilSystem → MechanicalAnimationSystem → EchoSystem → ProceduralMorphSystem → CrystallineCubeBossSystem → PostProcessCorruption → ImmersionAudioBridge → SpatialAudioManager → DreamTypeHandler → ARSessionManager → KeyboardInputSystem.
2. THE SystemOrchestrator SHALL update systems per frame in this order: KeyboardInputSystem (input) → PatternStabilizationSystem (gameplay) → DifficultyScalingSystem (difficulty recomputation) → TensionSystem (state) → CorruptionTendrilSystem (visuals) → ProceduralMorphSystem (enemies) → CrystallineCubeBossSystem (boss) → EchoSystem (feedback) → MechanicalDegradationSystem (fallback) → PostProcessCorruption (post-process) → ImmersionAudioBridge (audio) → DreamTypeHandler (archetype logic).
3. THE SystemOrchestrator SHALL provide a dispose method that tears down all systems in reverse initialization order.
4. THE SystemOrchestrator SHALL use direct singleton method calls for system-to-system communication (not an event bus), matching the Grok doc architecture.

### Requirement 33: Game Phase and Startup Sequence

**User Story:** As a player, I want a smooth startup experience from engine initialization through title screen to gameplay, so that the transition into the fragile glass world feels intentional and immersive.

#### Acceptance Criteria

1. WHEN the app launches, THE StartupSequence SHALL display a minimal loading indicator (diegetic: platter rim glow pulsing) while the engine initializes and configs load.
2. WHEN engine initialization completes, THE StartupSequence SHALL transition to the title phase: platter visible with "COGNITIVE DISSONANCE" engraving, sphere visible with calm blue nebula, garage-door slit closed, keycaps retracted.
3. WHEN the player presses Enter (keyboard), taps the Play key on the platter (touch), or pinches the Play key (XR hands), THE game-store SHALL transition from title to playing phase.
4. WHEN the playing phase begins, THE MechanicalAnimation_System SHALL animate the garage-door slit open, keycaps emerge via MotionPath, and the DreamTypeHandler SHALL spawn the first Dream from the buried seed.
5. WHEN the sphere shatters (tension 0.999), THE game-store SHALL transition to the shattered phase: sphere mesh fractures into 64 glass-shard particles via SolidParticleSystem, all enemies freeze and fade, platter stops rotating, "COGNITION SHATTERED" text appears.
6. WHEN the shattered phase has been active for 4 seconds, THE game-store SHALL enable restart: pressing Enter or tapping the platter generates a new seed and transitions back to the title phase.
7. IF engine initialization fails (WebGPU unavailable AND WebGL2 unavailable), THEN THE StartupSequence SHALL display a static HTML fallback message.

### Requirement 34: Shader Strategy (GLSL-First with WebGPU Auto-Conversion)

**User Story:** As a developer, I want all custom shaders written in GLSL with Babylon.js auto-converting to WGSL on WebGPU, so that shaders work on all platforms (web WebGPU, web WebGL2, native bgfx) without maintaining dual implementations.

#### Acceptance Criteria

1. ALL custom shaders (nebula, corruption tendril, AR occlusion, crystalline boss, neon raymarcher) SHALL be written in GLSL and stored as static string literals in Effect.ShadersStore (CSP-safe).
2. WHEN running on WebGPU, THE engine SHALL auto-convert GLSL to WGSL via Babylon.js built-in GLSL-to-WGSL transpiler (WASM-based, loaded on demand).
3. WHEN running on WebGL2 or Babylon Native (bgfx), THE engine SHALL use the GLSL shaders directly without conversion.
4. THE shader strategy SHALL NOT require any .wgsl files or custom Metro transformers for shader imports.
5. ALL shaders SHALL use Babylon.js ShaderMaterial or Effect APIs with uniform bindings for tension, time, corruptionLevel, and other dynamic parameters.

### Requirement 35: Babylon Native Integration Strategy

**User Story:** As a developer, I want a clear strategy for Babylon.js on React Native that accounts for the version compatibility gap, so that native builds don't fail due to unsupported RN versions.

#### Acceptance Criteria

1. THE native integration SHALL use Babylon Native directly (not @babylonjs/react-native) with a custom React Native bridge, bypassing the official package's RN 0.73 version cap.
2. THE native integration SHALL use Babylon Native's bgfx backend for Metal (iOS) and Vulkan/OpenGL ES (Android) rendering.
3. THE native integration SHALL provide a BabylonNativeView React Native component that creates a native rendering surface and bridges to the Babylon.js Engine API.
4. THE native integration SHALL share 95%+ of game logic code with the web build — only engine initialization and rendering surface creation differ.
5. IF the custom Babylon Native bridge proves infeasible during implementation, THEN THE fallback strategy SHALL be to pin React Native to the latest version supported by @babylonjs/react-native and use Expo prebuild to manage native dependencies.

### Requirement 36: AR Integration Strategy

**User Story:** As a developer, I want AR functionality that works without the non-existent expo-ar package, so that both web and native AR modes are achievable with real, available libraries.

#### Acceptance Criteria

1. ON WEB, THE AR_Session SHALL use Babylon.js WebXR API (WebXRDefaultExperience) with immersive-ar session mode, which is natively supported in Chrome, Edge, and Quest Browser.
2. ON iOS, THE AR_Session SHALL use a custom native module wrapping ARKit (ARSession + ARWorldTrackingConfiguration) that bridges AR frame data to Babylon Native's rendering pipeline.
3. ON Android, THE AR_Session SHALL use a custom native module wrapping ARCore (Session + Config) that bridges AR frame data to Babylon Native's rendering pipeline.
4. THE app.json plugins list SHALL replace "expo-ar" with "expo-camera" (for camera permissions) and custom native module config blocks for ARKit/ARCore.
5. IF custom AR native modules prove too complex for initial implementation, THEN THE fallback SHALL be WebXR-only AR (web + Quest) with native builds running in screen-mode (platter in dark void).

### Requirement 37: Seed-to-Gameplay Pipeline

**User Story:** As a developer, I want the buried seed pipeline fully specified from hash generation through pattern sequences, enemy traits, audio parameters, and archetype selection, so that deterministic procedural generation is implementable.

#### Acceptance Criteria

1. THE seed pipeline SHALL use mulberry32 hash from the seed string to produce a deterministic PRNG stream.
2. THE seed pipeline SHALL derive the Level_Archetype from seedHash % 4 (0=PlatterRotation, 1=LeverTension, 2=KeySequence, 3=CrystallineCubeBoss).
3. THE seed pipeline SHALL derive pattern sequences by consuming PRNG values to select from the phase's available patternKeys array, producing ordered sequences of 1–5 keys per pattern.
4. THE seed pipeline SHALL derive enemy trait distribution by consuming PRNG values modulo 7 to assign YukaTraits, with a bias toward the current archetype's thematic trait (e.g., PlatterCrusher more likely in PlatterRotationDream).
5. THE seed pipeline SHALL derive audio parameters: BPM = 60 + (PRNG % 80), swing = PRNG % 30 / 100, sequence root note = PRNG % 12 semitones.
6. WHEN a Dream is spawned, THE seed pipeline SHALL derive all phase parameters (tension thresholds, pattern keys, spawn rates, Yuka counts, boss triggers) and tension curve parameters (increase/decrease rates, over-stabilization thresholds, rebound probabilities) directly into ECS component data on the Level_Archetype entity via spawnDreamFromSeed, with seed-based variance of ±15% on spawn rates and hold times.
7. THE seed pipeline SHALL store all procedural parameters as Miniplex component values on Level_Archetype entities — no external JSON config files, no Babylon AssetManager config loading, and no configLoader system.

### Requirement 38: Sphere Shatter Sequence

**User Story:** As a player, I want the sphere shatter to be a dramatic, mechanically satisfying climax, so that the game-over moment feels like a real glass mind breaking apart.

#### Acceptance Criteria

1. WHEN tension reaches 0.999, THE ShatterSequence SHALL freeze all gameplay systems (pattern spawning, enemy movement, tendril growth) for 200ms.
2. AFTER the 200ms freeze, THE ShatterSequence SHALL fracture the sphere mesh into 64 glass-shard SolidParticles using Babylon.js SolidParticleSystem, with shards inheriting the sphere's current nebula color and flying outward with seed-derived velocity vectors.
3. THE ShatterSequence SHALL trigger a heavy haptic burst (expo-haptics Heavy + 200ms navigator.vibrate) and a Tone.js glass-shatter SFX (white noise burst through high-pass filter, 400ms decay).
4. THE ShatterSequence SHALL fade all active Yuka enemies to alpha 0 over 800ms and dispose them.
5. THE ShatterSequence SHALL stop platter rotation and retract all keycaps via GSAP reverse animation (400ms).
6. THE ShatterSequence SHALL display "COGNITION SHATTERED" as a plane mesh parented to the shatter center point, with red emissive text and GSAP yoyo scaling (3 repeats, 600ms each).

### Requirement 39: Physics Engine Configuration

**User Story:** As a developer, I want the physics engine specified and configured for keycap hold resistance and platter mechanics, so that physical interactions feel weighty and consistent.

#### Acceptance Criteria

1. THE physics engine SHALL be Havok (via @babylonjs/havok), matching the v2.0 implementation and Babylon.js 8 recommended physics plugin.
2. THE physics engine SHALL be initialized with gravity Vector3(0, -9.81, 0) and a fixed timestep of 1/60s.
3. THE physics engine SHALL apply 6DoF constraints to keycaps for spring-loaded hold resistance (LINEAR_Y stiffness 800, damping 40, travel 0.02m).
4. THE Havok WASM binary SHALL be loaded asynchronously during engine initialization and included in the production bundle size budget.

### Requirement 40: Performance Budget and Bundle Analysis

**User Story:** As a developer, I want automated enforcement of the 5 MB gzipped bundle target and runtime performance monitoring, so that the game stays within its performance budget across all platforms.

#### Acceptance Criteria

1. THE build pipeline SHALL include a post-build size check that fails CI if the gzipped web bundle exceeds 5 MB.
2. THE build pipeline SHALL generate a bundle analysis report on every CI build.
3. THE DeviceQuality_System SHALL monitor runtime FPS via engine.getFps() and dynamically reduce quality tier if FPS drops below 30 for more than 2 consecutive seconds.
4. THE tree-shaking strategy SHALL enforce @babylonjs/core subpath imports only — a lint rule or build-time check SHALL flag any barrel imports from '@babylonjs/core' or 'babylonjs'.

### Requirement 41: Multiplayer Transport Layer

**User Story:** As a developer, I want the SharedDreams multiplayer transport specified, so that anchor sync and shared corruption state can be implemented with a real networking solution.

#### Acceptance Criteria

1. THE SharedDreams_System SHALL use WebRTC DataChannel for peer-to-peer anchor sync and tension state sharing.
2. THE SharedDreams_System SHALL use a lightweight signaling server (WebSocket) for peer discovery and WebRTC offer/answer exchange.
3. THE SharedDreams_System SHALL sync AR anchor positions at 10 Hz and tension state at 30 Hz.
4. THE SharedDreams_System SHALL tolerate up to 200ms network latency without visible desync (interpolate remote platter position).
5.* THE multiplayer feature SHALL be considered optional (post-launch) and SHALL NOT block the core single-player implementation.

### Requirement 42: GSAP Plugin Usage

**User Story:** As a developer, I want GSAP and all plugins freely available in the project, so that CustomEase, MotionPath, and all formerly-paid plugins are usable without licensing concerns.

#### Acceptance Criteria

1. THE project SHALL install GSAP 3.13+ from the public npm registry (gsap package), which includes all plugins (CustomEase, MotionPath, MorphSVG, SplitText, etc.) at no cost for all use including commercial — per the Webflow-sponsored free license effective May 2025.
2. THE project SHALL import GSAP plugins directly from the gsap package (e.g., `import { CustomEase } from "gsap/CustomEase"`) — the private npm.greensock.com registry is deprecated and SHALL NOT be used.
3. THE MechanicalAnimation_System SHALL use CustomEase and MotionPath without any licensing restrictions or fallback implementations.


### Requirement 43: Procedural Difficulty Scaling System

**User Story:** As a player, I want the game's difficulty to scale endlessly with logarithmic progression driven by the buried seed, so that every run feels like an infinite, unique challenge that asymptotically approaches but never reaches a ceiling.

#### Acceptance Criteria

1. THE DifficultyScaling_System SHALL be a Miniplex ECS system that computes all difficulty parameters from the current tension value, elapsed time since Dream start, and the Buried_Seed PRNG stream.
2. THE DifficultyScaling_System SHALL use a logarithmic scaling model for all difficulty parameters: `scaledValue = baseValue * (1 + k * Math.log1p(tension * timeScale))` where k (scaling coefficient) and timeScale (time compression factor) are derived from the Buried_Seed PRNG with per-Dream variance of ±20%.
3. WHEN tension increases, THE DifficultyScaling_System SHALL recompute and write updated difficulty parameters to the active Level_Archetype entity's ECS components: spawnRate, maxEnemyCount, patternComplexity, morphSpeed, and bossSpawnThreshold.
4. THE DifficultyScaling_System SHALL scale spawn rate from a base interval (seed-derived 1.0–1.4s) down toward a floor of 0.2s using the logarithmic curve, so that patterns spawn faster as difficulty rises but never reach zero interval.
5. THE DifficultyScaling_System SHALL scale maximum concurrent enemy count from a base of 3 up toward an asymptotic ceiling of 24 using the logarithmic curve.
6. THE DifficultyScaling_System SHALL scale pattern complexity (number of keys per pattern) from a base of 1–2 up toward a maximum of 6 using stepped thresholds derived from the logarithmic curve.
7. THE DifficultyScaling_System SHALL scale morph speed (enemy morphProgress rate) from a base multiplier of 1.0 up toward 3.0 using the logarithmic curve.
8. THE DifficultyScaling_System SHALL scale boss spawn threshold from a base tension of 0.92 down toward 0.6 using the logarithmic curve, so that bosses appear earlier as difficulty increases.
9. WHEN a PlatterRotationDream is active, THE DifficultyScaling_System SHALL additionally scale platter rotation RPM from the seed-derived base (2–8 RPM) up toward 18 RPM using the logarithmic curve.
10. WHEN a LeverTensionDream is active, THE DifficultyScaling_System SHALL additionally scale lever frequency tolerance from the seed-derived base window (±0.15) down toward ±0.04 using the logarithmic curve.
11. WHEN a KeySequenceDream is active, THE DifficultyScaling_System SHALL additionally scale sequence length from the seed-derived base (2–3 keys) up toward 7 keys and scale the per-key time window from the seed-derived base (1200–2000ms) down toward 400ms using the logarithmic curve.
12. WHEN a CrystallineCubeBossDream is active, THE DifficultyScaling_System SHALL additionally scale boss slam cycles from 1 up toward 5 and scale counter window duration from 4s down toward 1.5s using the logarithmic curve.
13. THE DifficultyScaling_System SHALL form a feedback loop with the TensionSystem: difficulty drives the tension increase rate (higher difficulty = faster tension gain per missed pattern), and tension drives difficulty — with a damping coefficient (seed-derived 0.7–0.9) that prevents runaway escalation.
14. THE DifficultyScaling_System SHALL apply seed-derived variance of ±15–25% to all base values and scaling coefficients per Dream, ensuring no two Dreams with different seeds produce identical difficulty curves.
15. THE DifficultyScaling_System SHALL enforce that all scaled values asymptotically approach but never reach their ceiling/floor limits, guaranteeing endless progression with no level cap.
16. THE DifficultyScaling_System SHALL update difficulty parameters once per frame via scene.registerBeforeRender, reading tension from TensionSystem and elapsed time from the engine clock.
